<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Tests de Math√©matiques - Coll√®ge{% endblock %}</title>

    <!-- Canonical URL pour √©viter le contenu dupliqu√© -->
    {% block canonical %}
    {% if canonical_url %}
    <link rel="canonical" href="{{ canonical_url }}" />
    {% else %}
    <link rel="canonical" href="https://mathsetco.eu.pythonanywhere.com{{ url_for(request.endpoint, **request.view_args) if request.endpoint else request.path }}" />
    {% endif %}
    {% endblock %}

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome pour les ic√¥nes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Support MathML avec fallback MathJax -->
    <script>
        // D√©tection du support MathML natif
        window.mathMLSupported = (function() {
            var div = document.createElement('div');
            div.innerHTML = '<math><mspace height="23px" width="77px"/></math>';
            return div.firstChild && div.firstChild.firstChild &&
                   div.firstChild.firstChild.getBoundingClientRect().height > 19;
        })();

        // Si MathML n'est pas support√© nativement, charger MathJax
        if (!window.mathMLSupported) {
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$', '$$'], ['\\[', '\\]']]
                },
                mathml: {
                    displayMath: [['\\[', '\\]']],
                    inlineMath: [['\\(', '\\)']]
                },
                svg: {
                    fontCache: 'global'
                }
            };

            var script = document.createElement('script');
            script.src = 'https://polyfill.io/v3/polyfill.min.js?features=es6';
            document.head.appendChild(script);

            var mathjax = document.createElement('script');
            mathjax.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js';
            document.head.appendChild(mathjax);
        }
    </script>

    <!-- CKEditor 5 (Open Source) avec support MathML -->
    <script src="https://cdn.ckeditor.com/ckeditor5/40.0.0/classic/ckeditor.js"></script>
    <style>
        .ck-editor__editable {
            min-height: 200px;
        }
        .math-toolbar {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
        }
        .math-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            margin: 2px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .math-btn:hover {
            background: #0056b3;
        }
    </style>

    <script>
        // Configuration globale pour CKEditor avec support MathML
        window.editorInstances = {};

        function initMathEditor(elementId) {
            const element = document.getElementById(elementId);
            if (!element || window.editorInstances[elementId]) return;

            // Cr√©er la barre d'outils math√©matiques
            const mathToolbar = document.createElement('div');
            mathToolbar.className = 'math-toolbar';
            mathToolbar.innerHTML = `
                <div style="font-weight: bold; margin-bottom: 5px;">Formules math√©matiques :</div>
                <button type="button" class="math-btn" onclick="insertMath('${elementId}', 'frac')">Fraction</button>
                <button type="button" class="math-btn" onclick="insertMath('${elementId}', 'pow')">Puissance</button>
                <button type="button" class="math-btn" onclick="insertMath('${elementId}', 'sqrt')">Racine</button>
                <button type="button" class="math-btn" onclick="insertMath('${elementId}', 'root')">Racine n-i√®me</button>
                <button type="button" class="math-btn" onclick="insertMath('${elementId}', 'var')">Variable</button>
                <button type="button" class="math-btn" onclick="showMathDialog('${elementId}')">Guide complet</button>
            `;
            element.parentNode.insertBefore(mathToolbar, element);

            ClassicEditor
                .create(element, {
                    toolbar: [
                        'heading', '|',
                        'bold', 'italic', 'underline', '|',
                        'bulletedList', 'numberedList', '|',
                        'undo', 'redo'
                    ],
                    heading: {
                        options: [
                            { model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
                            { model: 'heading1', view: 'h1', title: 'Heading 1', class: 'ck-heading_heading1' },
                            { model: 'heading2', view: 'h2', title: 'Heading 2', class: 'ck-heading_heading2' }
                        ]
                    }
                })
                .then(editor => {
                    window.editorInstances[elementId] = editor;

                    // Charger le contenu initial s'il existe
                    const initialContent = element.value || element.textContent;
                    if (initialContent) {
                        editor.setData(convertNotationToMathML(initialContent));
                    }

                    // Synchroniser avec le textarea lors des changements
                    editor.model.document.on('change:data', () => {
                        const content = editor.getData();
                        const convertedContent = convertMathMLToNotation(content);
                        element.value = convertedContent;

                        // D√©clencher l'√©v√©nement change pour la sauvegarde automatique
                        element.dispatchEvent(new Event('change'));
                    });
                })
                .catch(error => {
                    console.error('Erreur lors de l\'initialisation de CKEditor:', error);
                });
        }

        function insertMath(editorId, type) {
            const editor = window.editorInstances[editorId];
            if (!editor) return;

            let mathText = '';

            switch(type) {
                case 'frac':
                    mathText = '[frac:3/4]';
                    break;
                case 'pow':
                    mathText = '[pow:x^2]';
                    break;
                case 'sqrt':
                    mathText = '[sqrt:16]';
                    break;
                case 'root':
                    mathText = '[root:8,3]';
                    break;
                case 'var':
                    mathText = '[var:x_1]';
                    break;
            }

            editor.model.change(writer => {
                const insertPosition = editor.model.document.selection.getFirstPosition();
                writer.insertText(mathText, insertPosition);
            });
        }

        function showMathDialog(editorId) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 10px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h4>üßÆ Guide des formules math√©matiques</h4>
                        <button onclick="this.closest('.modal-overlay').remove()" style="background: none; border: none; font-size: 24px; cursor: pointer;">&times;</button>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h5>üìù Syntaxes disponibles :</h5>
                        <div style="font-family: monospace; background: #f5f5f5; padding: 15px; border-radius: 8px; margin: 10px 0;">
                            <div style="margin: 8px 0;"><strong>Fractions :</strong> [frac:3/4] ‚Üí ¬æ</div>
                            <div style="margin: 8px 0;"><strong>Puissances :</strong> [pow:x^2] ‚Üí x¬≤</div>
                            <div style="margin: 8px 0;"><strong>Racines :</strong> [sqrt:16] ‚Üí ‚àö16</div>
                            <div style="margin: 8px 0;"><strong>Racines n-i√®mes :</strong> [root:8,3] ‚Üí ‚àõ8</div>
                            <div style="margin: 8px 0;"><strong>Variables :</strong> [var:x_1] ‚Üí x‚ÇÅ</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label for="formula-input" style="font-weight: bold;">Tapez votre formule :</label>
                        <textarea id="formula-input" style="width: 100%; height: 80px; margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 4px;" placeholder="Exemple: Calculer [frac:3/4] + [pow:x^2]"></textarea>

                        <div style="margin: 10px 0;">
                            <strong>Aper√ßu :</strong>
                            <div id="formula-preview" style="border: 1px solid #ddd; padding: 15px; background: white; min-height: 50px; border-radius: 4px;">
                                <em>Tapez une formule ci-dessus...</em>
                            </div>
                        </div>
                    </div>

                    <div style="text-align: right;">
                        <button onclick="this.closest('.modal-overlay').remove()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 4px; margin-right: 10px; cursor: pointer;">Annuler</button>
                        <button onclick="insertFormulaFromDialog('${editorId}')" style="background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Ins√©rer</button>
                    </div>
                </div>
            `;

            modal.className = 'modal-overlay';
            document.body.appendChild(modal);

            // Aper√ßu en temps r√©el
            const input = modal.querySelector('#formula-input');
            const preview = modal.querySelector('#formula-preview');

            input.addEventListener('input', function() {
                const converted = convertNotationToMathML(this.value);
                preview.innerHTML = converted || '<em>Tapez une formule...</em>';
            });

            input.focus();
        }

        function insertFormulaFromDialog(editorId) {
            const modal = document.querySelector('.modal-overlay');
            const input = modal.querySelector('#formula-input');
            const editor = window.editorInstances[editorId];

            if (editor && input.value.trim()) {
                editor.model.change(writer => {
                    const insertPosition = editor.model.document.selection.getFirstPosition();
                    writer.insertText(input.value, insertPosition);
                });
            }

            modal.remove();
        }

        // Fonctions de conversion am√©lior√©es pour les expressions imbriqu√©es
        function convertNotationToMathML(text) {
            if (!text) return text;

            // Nouvelle syntaxe pour expressions complexes [math:...]
            text = text.replace(/\[math:([^\]]+)\]/g, function(match, expr) {
                try {
                    return parseComplexMathExpression(expr);
                } catch (e) {
                    console.error('Erreur parsing math:', e);
                    return match;
                }
            });

            // Traitement r√©cursif des expressions imbriqu√©es
            return parseNestedMathExpressions(text);
        }

        function parseNestedMathExpressions(text) {
            // R√©p√©ter jusqu'√† ce qu'il n'y ait plus d'expressions √† traiter
            let previousText = '';
            let currentText = text;

            while (previousText !== currentText) {
                previousText = currentText;

                // Traiter les expressions de l'int√©rieur vers l'ext√©rieur
                // D'abord les expressions les plus simples (sans imbrication)
                currentText = currentText
                    .replace(/\[sqrt:([^\[\]]+)\]/g, function(match, value) {
                        const parsedValue = parseInnerExpression(value.trim());
                        return `<math class="math-inline"><msqrt>${parsedValue}</msqrt></math>`;
                    })
                    .replace(/\[pow:([^\[\]]+)\]/g, function(match, expr) {
                        if (expr.includes('^')) {
                            const [base, exp] = expr.split('^');
                            const parsedBase = parseInnerExpression(base.trim());
                            const parsedExp = parseInnerExpression(exp.trim());
                            return `<math class="math-inline"><msup>${parsedBase}${parsedExp}</msup></math>`;
                        }
                        return match;
                    })
                    .replace(/\[root:([^\[\]]+)\]/g, function(match, values) {
                        const parts = values.split(',');
                        if (parts.length === 2) {
                            const parsedRadicande = parseInnerExpression(parts[0].trim());
                            const parsedIndice = parseInnerExpression(parts[1].trim());
                            return `<math class="math-inline"><mroot>${parsedRadicande}${parsedIndice}</mroot></math>`;
                        }
                        return match;
                    })
                    .replace(/\[var:([^\[\]]+)\]/g, function(match, variable) {
                        if (variable.includes('_')) {
                            const [nom, indice] = variable.split('_');
                            return `<math class="math-inline"><msub><mi>${nom.trim()}</mi><mn>${indice.trim()}</mn></msub></math>`;
                        } else {
                            return `<math class="math-inline"><mi>${variable.trim()}</mi></math>`;
                        }
                    });

                // Traiter les fractions avec un algorithme sp√©cial pour les expressions imbriqu√©es
                currentText = parseFractions(currentText);
            }

            return currentText;
        }

        function parseFractions(text) {
            // Rechercher toutes les occurrences de [frac:...] avec gestion des crochets imbriqu√©s
            let result = text;
            let index = 0;

            while (index < result.length) {
                const fracStart = result.indexOf('[frac:', index);
                if (fracStart === -1) break;

                const contentStart = fracStart + 6; // longueur de '[frac:'
                let bracketCount = 1;
                let contentEnd = contentStart;

                // Trouver la fin de l'expression en comptant les crochets
                while (contentEnd < result.length && bracketCount > 0) {
                    if (result[contentEnd] === '[') {
                        bracketCount++;
                    } else if (result[contentEnd] === ']') {
                        bracketCount--;
                    }
                    contentEnd++;
                }

                if (bracketCount === 0) {
                    const fracContent = result.substring(contentStart, contentEnd - 1);

                    if (fracContent.includes('/')) {
                        // Trouver la position du / en tenant compte des crochets imbriqu√©s
                        const slashPos = findMainSlash(fracContent);
                        if (slashPos !== -1) {
                            const num = fracContent.substring(0, slashPos).trim();
                            const den = fracContent.substring(slashPos + 1).trim();
                            const parsedNum = parseInnerExpression(num);
                            const parsedDen = parseInnerExpression(den);

                            const replacement = `<math class="math-inline"><mfrac>${parsedNum}${parsedDen}</mfrac></math>`;
                            result = result.substring(0, fracStart) + replacement + result.substring(contentEnd);
                            index = fracStart + replacement.length;
                        } else {
                            index = contentEnd;
                        }
                    } else {
                        index = contentEnd;
                    }
                } else {
                    break;
                }
            }

            return result;
        }

        function findMainSlash(content) {
            // Trouver la position du / principal (pas dans des crochets imbriqu√©s)
            let bracketCount = 0;
            for (let i = 0; i < content.length; i++) {
                if (content[i] === '[') {
                    bracketCount++;
                } else if (content[i] === ']') {
                    bracketCount--;
                } else if (content[i] === '/' && bracketCount === 0) {
                    return i;
                }
            }
            return -1;
        }

        function parseInnerExpression(expr) {
            // Si l'expression contient du MathML d√©j√† pars√©, l'extraire
            if (expr.includes('<math class="math-inline">')) {
                // Extraire le contenu entre <math> et </math>
                const mathMatch = expr.match(/<math class="math-inline">(.*?)<\/math>/);
                if (mathMatch) {
                    return mathMatch[1];
                }
            }

            // G√©rer les divisions avec / pour les fractions
            if (expr.includes('/') && !expr.includes('<m')) {
                const parts = expr.split('/');
                if (parts.length === 2) {
                    const num = parseInnerExpression(parts[0].trim());
                    const den = parseInnerExpression(parts[1].trim());
                    return `<mfrac>${num}${den}</mfrac>`;
                }
            }

            // Si c'est un nombre simple
            if (/^-?\d+(\.\d+)?$/.test(expr)) {
                return `<mn>${expr}</mn>`;
            }

            // Si c'est une variable simple
            if (/^[a-zA-Z]$/.test(expr)) {
                return `<mi>${expr}</mi>`;
            }

            // Variables avec plusieurs caract√®res
            if (/^[a-zA-Z_]\w*$/.test(expr)) {
                return `<mi>${expr}</mi>`;
            }

            // Par d√©faut, traiter comme du texte
            return `<mn>${expr}</mn>`;
        }

        // Nouvelle fonction pour parser les expressions math√©matiques complexes
        function parseComplexMathExpression(expr) {
            expr = expr.trim();

            // Traiter les fonctions math√©matiques de mani√®re r√©cursive
            while (true) {
                const match = expr.match(/(sqrt|pow|frac)\s*\(/);
                if (!match) break;

                const funcName = match[1];
                const startPos = match.index;
                const parenStart = expr.indexOf('(', startPos);
                const parenEnd = findMatchingParen(expr, parenStart);

                if (parenEnd === -1) break;

                const funcContent = expr.substring(parenStart + 1, parenEnd);
                let replacement = '';

                if (funcName === 'sqrt') {
                    const parsedContent = parseSimpleExpression(funcContent);
                    replacement = `<msqrt>${parsedContent}</msqrt>`;
                } else if (funcName === 'pow') {
                    const parts = splitFunctionArgs(funcContent);
                    if (parts.length === 2) {
                        const base = parseSimpleExpression(parts[0]);
                        const exp = parseSimpleExpression(parts[1]);
                        replacement = `<msup>${base}${exp}</msup>`;
                    }
                } else if (funcName === 'frac') {
                    const parts = splitFunctionArgs(funcContent);
                    if (parts.length === 2) {
                        const num = parseSimpleExpression(parts[0]);
                        const den = parseSimpleExpression(parts[1]);
                        replacement = `<mfrac>${num}${den}</mfrac>`;
                    }
                }

                expr = expr.substring(0, startPos) + replacement + expr.substring(parenEnd + 1);
            }

            const finalParsed = parseSimpleExpression(expr);
            return `<math class="math-inline">${finalParsed}</math>`;
        }

        function findMatchingParen(text, startPos) {
            let count = 1;
            let pos = startPos + 1;

            while (pos < text.length && count > 0) {
                if (text[pos] === '(') count++;
                else if (text[pos] === ')') count--;
                pos++;
            }

            return count === 0 ? pos - 1 : -1;
        }

        function splitFunctionArgs(content) {
            const args = [];
            let currentArg = '';
            let parenCount = 0;

            for (const char of content) {
                if (char === ',' && parenCount === 0) {
                    args.push(currentArg.trim());
                    currentArg = '';
                } else {
                    if (char === '(') parenCount++;
                    else if (char === ')') parenCount--;
                    currentArg += char;
                }
            }

            if (currentArg.trim()) {
                args.push(currentArg.trim());
            }

            return args;
        }

        function parseSimpleExpression(expr) {
            expr = expr.trim();

            if (!expr) return '<mi></mi>';

            // Si c'est d√©j√† du MathML, le retourner tel quel
            if (expr.startsWith('<m') && expr.endsWith('>')) {
                return expr;
            }

            // Si c'est un nombre
            if (/^-?\d+(\.\d+)?$/.test(expr)) {
                return `<mn>${expr}</mn>`;
            }

            // Si c'est une variable simple
            if (/^[a-zA-Z]$/.test(expr)) {
                return `<mi>${expr}</mi>`;
            }

            // G√©rer les op√©rateurs + et -
            for (const op of ['+', '-']) {
                let parenCount = 0;
                for (let i = 1; i < expr.length; i++) { // Commencer √† 1 pour √©viter le - initial
                    if (expr[i] === '(') parenCount++;
                    else if (expr[i] === ')') parenCount--;
                    else if (expr[i] === op && parenCount === 0) {
                        const left = parseSimpleExpression(expr.substring(0, i));
                        const right = parseSimpleExpression(expr.substring(i + 1));
                        return `${left}<mo>${op}</mo>${right}`;
                    }
                }
            }

            // G√©rer les op√©rateurs * et /
            for (const op of ['*', '/']) {
                let parenCount = 0;
                for (let i = 0; i < expr.length; i++) {
                    if (expr[i] === '(') parenCount++;
                    else if (expr[i] === ')') parenCount--;
                    else if (expr[i] === op && parenCount === 0) {
                        const left = parseSimpleExpression(expr.substring(0, i));
                        const right = parseSimpleExpression(expr.substring(i + 1));
                        const opSymbol = op === '*' ? '√ó' : '√∑';
                        return `${left}<mo>${opSymbol}</mo>${right}`;
                    }
                }
            }

            // Si l'expression est entre parenth√®ses, les enlever
            if (expr.startsWith('(') && expr.endsWith(')')) {
                return parseSimpleExpression(expr.substring(1, expr.length - 1));
            }

            // Variables avec plusieurs caract√®res
            if (/^[a-zA-Z_]\w*$/.test(expr)) {
                return `<mi>${expr}</mi>`;
            }

            // Par d√©faut
            return `<mi>${expr}</mi>`;
        }

        function convertMathMLToNotation(text) {
            if (!text) return text;

            // Conversion inverse pour sauvegarder en notation simple
            return text
                .replace(/<math[^>]*><mfrac><mn>([^<]+)<\/mn><mn>([^<]+)<\/mn><\/mfrac><\/math>/g, '[frac:$1/$2]')
                .replace(/<math[^>]*><msup><mn>([^<]+)<\/mn><mn>([^<]+)<\/mn><\/msup><\/math>/g, '[pow:$1^$2]')
                .replace(/<math[^>]*><msqrt><mn>([^<]+)<\/mn><\/msqrt><\/math>/g, '[sqrt:$1]')
                .replace(/<math[^>]*><mroot><mn>([^<]+)<\/mn><mn>([^<]+)<\/mn><\/mroot><\/math>/g, '[root:$1,$2]')
                .replace(/<math[^>]*><msub><mi>([^<]+)<\/mi><mn>([^<]+)<\/mn><\/msub><\/math>/g, '[var:$1_$2]');
        }

        // Sauvegarde automatique des brouillons
        function enableAutoSave() {
            Object.keys(window.editorInstances).forEach(editorId => {
                const editor = window.editorInstances[editorId];
                if (editor) {
                    editor.model.document.on('change:data', () => {
                        const content = editor.getData();
                        localStorage.setItem('draft_' + editorId, content);
                    });
                }
            });
        }

        // Charger les brouillons sauvegard√©s
        function loadDrafts() {
            Object.keys(window.editorInstances).forEach(editorId => {
                const editor = window.editorInstances[editorId];
                const draft = localStorage.getItem('draft_' + editorId);
                if (editor && draft) {
                    editor.setData(draft);
                }
            });
        }
    </script>

    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .card {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            border-radius: 25px;
            padding: 10px 30px;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .math-icon {
            font-size: 3rem;
            color: #667eea;
        }

        /* Styles pour les formules math√©matiques */
        .math-content {
            line-height: 1.6;
        }

        .math-content math {
            font-size: 1.1em;
        }

        .math-inline {
            display: inline-block;
            vertical-align: middle;
        }

        .math-display {
            display: block;
            text-align: center;
            margin: 1em 0;
        }

        /* Am√©lioration de l'affichage des fractions */
        .math-content mfrac {
            font-size: 0.9em;
        }

        /* Style pour les exposants et indices */
        .math-content msup, .math-content msub {
            font-size: 0.8em;
        }
    </style>

    <!-- Meta description sp√©cifique par page -->
    {% block meta_description %}
    <meta name="description" content="Tests de math√©matiques interactifs pour le coll√®ge (QCM, corrig√©s, niveaux 6e √† 3e). D√©mo gratuite en ligne." />
    {% endblock %}

    <meta name="keywords" content="math√©matiques, coll√®ge, QCM, quiz, exercices, corrig√©s, 6√®me, 5√®me, 4√®me, 3√®me, manuel, PDF, √©ducation, r√©vision, test, chapitre, cours, m√©thode, correction, ressources, MathœÄSet, MathSetCo, mathssetco, mathsetco.eu, open source, Python, Flask, √©valuation, contr√¥le, pr√©paration, brevet, math√©matiques coll√®ge, math√©matiques interactives, math√©matiques en ligne, math√©matiques gratuites">

    <!-- Schema.org JSON-LD sp√©cifique par page -->
    {% block structured_data %}
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "EducationalOrganization",
      "name": "MathœÄSet&Co",
      "url": "https://mathsetco.eu.pythonanywhere.com/",
      "description": "Tests de math√©matiques interactifs pour le coll√®ge (QCM, corrig√©s, niveaux 6e √† 3e). D√©mo gratuite en ligne.",
      "keywords": [
        "math√©matiques", "coll√®ge", "QCM", "quiz", "exercices", "corrig√©s", "6√®me", "5√®me", "4√®me", "3√®me", "manuel", "PDF", "√©ducation", "r√©vision", "test", "chapitre", "cours", "m√©thode", "correction", "ressources", "MathœÄSet", "MathSetCo", "mathsetco.eu", "open source", "Python", "Flask", "√©valuation", "contr√¥le", "pr√©paration", "brevet", "math√©matiques coll√®ge", "math√©matiques interactives", "math√©matiques en ligne", "math√©matiques gratuites"
      ]
    }
    </script>
    {% endblock %}

    <!-- Open Graph avec donn√©es dynamiques -->
    {% block og_tags %}
    <meta property="og:title" content="{% block og_title %}Tests de Math√©matiques - Coll√®ge | MathœÄSetüéæ&Co{% endblock %}" />
    <meta property="og:description" content="{% block og_description %}Tests de math√©matiques interactifs pour le coll√®ge (QCM, corrig√©s, niveaux 6e √† 3e).{% endblock %}" />
    <meta property="og:url" content="https://mathsetco.eu.pythonanywhere.com{{ request.path }}" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="https://mathsetco.eu.pythonanywhere.com/static/Logos.png" />
    {% endblock %}

    <!-- Twitter Card avec donn√©es dynamiques -->
    {% block twitter_tags %}
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="{% block twitter_title %}Tests de Math√©matiques - Coll√®ge | MathœÄSetüéæ&Co{% endblock %}" />
    <meta name="twitter:description" content="{% block twitter_description %}Tests de math√©matiques interactifs pour le coll√®ge (QCM, corrig√©s, niveaux 6e √† 3e).{% endblock %}" />
    <meta name="twitter:image" content="https://mathsetco.eu.pythonanywhere.com/static/Logos.png" />
    {% endblock %}
</head>
<body>
    <header class="text-center py-3">
        <img src="{{ url_for('static', filename='Logos.png') }}" alt="Logo MathœÄSet&Co" style="height:70px;max-width:180px;">
    </header>
    <div class="container my-5">
        <div class="row justify-content-center">
            <div class="col-md-8">
                {% with messages = get_flashed_messages() %}
                    {% if messages %}
                        {% for message in messages %}
                            <div class="alert alert-warning alert-dismissible fade show" role="alert">
                                {{ message }}
                                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                            </div>
                        {% endfor %}
                    {% endif %}
                {% endwith %}

                {% block content %}{% endblock %}
            </div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <footer class="text-center mt-5 py-4 bg-light border-top">
        <span style="font-size:2rem;">MathœÄSetüéæ&Co</span>
        <span class="ms-2">‚Äî Projet open source sur <a href="https://github.com/pmourey/Maths-Set-Co.git" target="_blank">GitHub</a></span>
    </footer>
</body>
</html>
